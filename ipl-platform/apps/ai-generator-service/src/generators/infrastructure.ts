export interface InfraContext {
  domain: string;
  database: string;
  tier: string;
  appServers: number;
  dbReplicas: number;
  cacheNodes: number;
  region?: string;
  projectName?: string;
}

export function generateTerraform(ctx: InfraContext): string {
  const project = ctx.projectName || `${ctx.domain}-platform`;
  const region = ctx.region || 'us-east-1';
  
  return `# Terraform Configuration for ${project}
# Generated by Intelligent Platform Launcher

terraform {
  required_version = ">= 1.0.0"
  required_providers {
    aws = {
      source  = "hashicorp/aws"
      version = "~> 5.0"
    }
  }
  
  backend "s3" {
    bucket         = "${project}-terraform-state"
    key            = "state/terraform.tfstate"
    region         = "${region}"
    encrypt        = true
    dynamodb_table = "${project}-terraform-locks"
  }
}

provider "aws" {
  region = var.aws_region
  
  default_tags {
    tags = {
      Project     = "${project}"
      Environment = var.environment
      ManagedBy   = "Terraform"
    }
  }
}

# Variables
variable "aws_region" {
  description = "AWS region"
  type        = string
  default     = "${region}"
}

variable "environment" {
  description = "Environment name"
  type        = string
  default     = "production"
}

variable "vpc_cidr" {
  description = "VPC CIDR block"
  type        = string
  default     = "10.0.0.0/16"
}

# VPC
module "vpc" {
  source  = "terraform-aws-modules/vpc/aws"
  version = "~> 5.0"

  name = "${project}-vpc"
  cidr = var.vpc_cidr

  azs             = ["${region}a", "${region}b", "${region}c"]
  private_subnets = ["10.0.1.0/24", "10.0.2.0/24", "10.0.3.0/24"]
  public_subnets  = ["10.0.101.0/24", "10.0.102.0/24", "10.0.103.0/24"]

  enable_nat_gateway   = true
  single_nat_gateway   = var.environment != "production"
  enable_dns_hostnames = true
  enable_dns_support   = true
}

# Security Groups
resource "aws_security_group" "app" {
  name_prefix = "${project}-app-"
  vpc_id      = module.vpc.vpc_id

  ingress {
    from_port   = 80
    to_port     = 80
    protocol    = "tcp"
    cidr_blocks = ["0.0.0.0/0"]
  }

  ingress {
    from_port   = 443
    to_port     = 443
    protocol    = "tcp"
    cidr_blocks = ["0.0.0.0/0"]
  }

  egress {
    from_port   = 0
    to_port     = 0
    protocol    = "-1"
    cidr_blocks = ["0.0.0.0/0"]
  }
}

resource "aws_security_group" "db" {
  name_prefix = "${project}-db-"
  vpc_id      = module.vpc.vpc_id

  ingress {
    from_port       = ${ctx.database === 'postgresql' ? '5432' : ctx.database === 'mysql' ? '3306' : ctx.database === 'mongodb' ? '27017' : '5432'}
    to_port         = ${ctx.database === 'postgresql' ? '5432' : ctx.database === 'mysql' ? '3306' : ctx.database === 'mongodb' ? '27017' : '5432'}
    protocol        = "tcp"
    security_groups = [aws_security_group.app.id]
  }
}

# ECS Cluster
resource "aws_ecs_cluster" "main" {
  name = "${project}-cluster"

  setting {
    name  = "containerInsights"
    value = "enabled"
  }
}

resource "aws_ecs_cluster_capacity_providers" "main" {
  cluster_name = aws_ecs_cluster.main.name

  capacity_providers = ["FARGATE", "FARGATE_SPOT"]

  default_capacity_provider_strategy {
    base              = 1
    weight            = 100
    capacity_provider = "FARGATE"
  }
}

# Application Load Balancer
resource "aws_lb" "main" {
  name               = "${project}-alb"
  internal           = false
  load_balancer_type = "application"
  security_groups    = [aws_security_group.app.id]
  subnets            = module.vpc.public_subnets

  enable_deletion_protection = var.environment == "production"
}

resource "aws_lb_target_group" "app" {
  name        = "${project}-tg"
  port        = 80
  protocol    = "HTTP"
  vpc_id      = module.vpc.vpc_id
  target_type = "ip"

  health_check {
    healthy_threshold   = 2
    unhealthy_threshold = 10
    timeout             = 30
    interval            = 60
    path                = "/health"
    matcher             = "200"
  }
}

# RDS Database
${ctx.database === 'postgresql' || ctx.database === 'mysql' ? `
resource "aws_db_subnet_group" "main" {
  name       = "${project}-db-subnet"
  subnet_ids = module.vpc.private_subnets
}

resource "aws_rds_cluster" "main" {
  cluster_identifier     = "${project}-db"
  engine                 = "${ctx.database === 'postgresql' ? 'aurora-postgresql' : 'aurora-mysql'}"
  engine_mode            = "provisioned"
  database_name          = "${project.replace(/-/g, '_')}"
  master_username        = "admin"
  master_password        = var.db_password
  db_subnet_group_name   = aws_db_subnet_group.main.name
  vpc_security_group_ids = [aws_security_group.db.id]
  skip_final_snapshot    = var.environment != "production"
  
  serverlessv2_scaling_configuration {
    min_capacity = 0.5
    max_capacity = ${ctx.tier === 'Small' ? '4' : ctx.tier === 'Medium' ? '16' : ctx.tier === 'Large' ? '64' : '128'}
  }
}

resource "aws_rds_cluster_instance" "main" {
  count              = ${ctx.dbReplicas + 1}
  identifier         = "${project}-db-\${count.index}"
  cluster_identifier = aws_rds_cluster.main.id
  instance_class     = "db.serverless"
  engine             = aws_rds_cluster.main.engine
}

variable "db_password" {
  description = "Database master password"
  type        = string
  sensitive   = true
}
` : '# Using managed NoSQL service'}

# ElastiCache Redis
${ctx.cacheNodes > 0 ? `
resource "aws_elasticache_subnet_group" "main" {
  name       = "${project}-cache-subnet"
  subnet_ids = module.vpc.private_subnets
}

resource "aws_elasticache_replication_group" "main" {
  replication_group_id       = "${project}-cache"
  description                = "Redis cache for ${project}"
  node_type                  = "${ctx.tier === 'Small' ? 'cache.t3.micro' : ctx.tier === 'Medium' ? 'cache.r6g.large' : 'cache.r6g.xlarge'}"
  num_cache_clusters         = ${ctx.cacheNodes}
  port                       = 6379
  subnet_group_name          = aws_elasticache_subnet_group.main.name
  security_group_ids         = [aws_security_group.db.id]
  automatic_failover_enabled = ${ctx.cacheNodes > 1 ? 'true' : 'false'}
  at_rest_encryption_enabled = true
  transit_encryption_enabled = true
}
` : '# No cache configured'}

# Outputs
output "vpc_id" {
  value = module.vpc.vpc_id
}

output "alb_dns_name" {
  value = aws_lb.main.dns_name
}

output "ecs_cluster_name" {
  value = aws_ecs_cluster.main.name
}

${ctx.database === 'postgresql' || ctx.database === 'mysql' ? `
output "database_endpoint" {
  value = aws_rds_cluster.main.endpoint
}
` : ''}
`;
}

export function generateCloudFormation(ctx: InfraContext): string {
  const project = ctx.projectName || `${ctx.domain}-platform`;
  
  return `AWSTemplateFormatVersion: '2010-09-09'
Description: '${project} Infrastructure Stack'

Parameters:
  Environment:
    Type: String
    Default: production
    AllowedValues:
      - development
      - staging
      - production
  
  VpcCIDR:
    Type: String
    Default: 10.0.0.0/16
  
  DBPassword:
    Type: String
    NoEcho: true
    Description: Database master password

Resources:
  # VPC
  VPC:
    Type: AWS::EC2::VPC
    Properties:
      CidrBlock: !Ref VpcCIDR
      EnableDnsHostnames: true
      EnableDnsSupport: true
      Tags:
        - Key: Name
          Value: ${project}-vpc

  # Internet Gateway
  InternetGateway:
    Type: AWS::EC2::InternetGateway
    Properties:
      Tags:
        - Key: Name
          Value: ${project}-igw

  InternetGatewayAttachment:
    Type: AWS::EC2::VPCGatewayAttachment
    Properties:
      InternetGatewayId: !Ref InternetGateway
      VpcId: !Ref VPC

  # Public Subnets
  PublicSubnet1:
    Type: AWS::EC2::Subnet
    Properties:
      VpcId: !Ref VPC
      AvailabilityZone: !Select [0, !GetAZs '']
      CidrBlock: 10.0.1.0/24
      MapPublicIpOnLaunch: true
      Tags:
        - Key: Name
          Value: ${project}-public-1

  PublicSubnet2:
    Type: AWS::EC2::Subnet
    Properties:
      VpcId: !Ref VPC
      AvailabilityZone: !Select [1, !GetAZs '']
      CidrBlock: 10.0.2.0/24
      MapPublicIpOnLaunch: true
      Tags:
        - Key: Name
          Value: ${project}-public-2

  # Private Subnets
  PrivateSubnet1:
    Type: AWS::EC2::Subnet
    Properties:
      VpcId: !Ref VPC
      AvailabilityZone: !Select [0, !GetAZs '']
      CidrBlock: 10.0.10.0/24
      Tags:
        - Key: Name
          Value: ${project}-private-1

  PrivateSubnet2:
    Type: AWS::EC2::Subnet
    Properties:
      VpcId: !Ref VPC
      AvailabilityZone: !Select [1, !GetAZs '']
      CidrBlock: 10.0.11.0/24
      Tags:
        - Key: Name
          Value: ${project}-private-2

  # ECS Cluster
  ECSCluster:
    Type: AWS::ECS::Cluster
    Properties:
      ClusterName: ${project}-cluster
      ClusterSettings:
        - Name: containerInsights
          Value: enabled

  # Application Load Balancer
  ALBSecurityGroup:
    Type: AWS::EC2::SecurityGroup
    Properties:
      GroupDescription: Security group for ALB
      VpcId: !Ref VPC
      SecurityGroupIngress:
        - IpProtocol: tcp
          FromPort: 80
          ToPort: 80
          CidrIp: 0.0.0.0/0
        - IpProtocol: tcp
          FromPort: 443
          ToPort: 443
          CidrIp: 0.0.0.0/0

  ApplicationLoadBalancer:
    Type: AWS::ElasticLoadBalancingV2::LoadBalancer
    Properties:
      Name: ${project}-alb
      Scheme: internet-facing
      Type: application
      Subnets:
        - !Ref PublicSubnet1
        - !Ref PublicSubnet2
      SecurityGroups:
        - !Ref ALBSecurityGroup

  # RDS Aurora Cluster
  DBSubnetGroup:
    Type: AWS::RDS::DBSubnetGroup
    Properties:
      DBSubnetGroupDescription: Subnet group for RDS
      SubnetIds:
        - !Ref PrivateSubnet1
        - !Ref PrivateSubnet2

  DBSecurityGroup:
    Type: AWS::EC2::SecurityGroup
    Properties:
      GroupDescription: Security group for RDS
      VpcId: !Ref VPC
      SecurityGroupIngress:
        - IpProtocol: tcp
          FromPort: ${ctx.database === 'postgresql' ? '5432' : '3306'}
          ToPort: ${ctx.database === 'postgresql' ? '5432' : '3306'}
          SourceSecurityGroupId: !Ref ALBSecurityGroup

  RDSCluster:
    Type: AWS::RDS::DBCluster
    Properties:
      Engine: ${ctx.database === 'postgresql' ? 'aurora-postgresql' : 'aurora-mysql'}
      EngineMode: provisioned
      DatabaseName: ${project.replace(/-/g, '')}
      MasterUsername: admin
      MasterUserPassword: !Ref DBPassword
      DBSubnetGroupName: !Ref DBSubnetGroup
      VpcSecurityGroupIds:
        - !Ref DBSecurityGroup
      ServerlessV2ScalingConfiguration:
        MinCapacity: 0.5
        MaxCapacity: ${ctx.tier === 'Small' ? '4' : ctx.tier === 'Medium' ? '16' : '64'}

Outputs:
  VpcId:
    Description: VPC ID
    Value: !Ref VPC
    Export:
      Name: !Sub '\${AWS::StackName}-VpcId'
  
  ALBDNSName:
    Description: ALB DNS Name
    Value: !GetAtt ApplicationLoadBalancer.DNSName
    Export:
      Name: !Sub '\${AWS::StackName}-ALBDNSName'
  
  ECSClusterName:
    Description: ECS Cluster Name
    Value: !Ref ECSCluster
    Export:
      Name: !Sub '\${AWS::StackName}-ECSCluster'
`;
}

export function generateDockerfile(ctx: InfraContext): string {
  return `# Multi-stage Dockerfile for ${ctx.domain} Platform
# Generated by Intelligent Platform Launcher

# Stage 1: Build
FROM node:20-alpine AS builder

WORKDIR /app

# Install dependencies
COPY package*.json ./
RUN npm ci --only=production

# Copy source and build
COPY . .
RUN npm run build

# Stage 2: Production
FROM node:20-alpine AS production

WORKDIR /app

# Security: Create non-root user
RUN addgroup -g 1001 -S nodejs && \\
    adduser -S nodejs -u 1001

# Copy built assets
COPY --from=builder --chown=nodejs:nodejs /app/dist ./dist
COPY --from=builder --chown=nodejs:nodejs /app/node_modules ./node_modules
COPY --from=builder --chown=nodejs:nodejs /app/package*.json ./

# Environment
ENV NODE_ENV=production
ENV PORT=3000

# Health check
HEALTHCHECK --interval=30s --timeout=3s --start-period=5s --retries=3 \\
  CMD wget --no-verbose --tries=1 --spider http://localhost:3000/health || exit 1

# Run as non-root
USER nodejs

EXPOSE 3000

CMD ["node", "dist/server.js"]
`;
}

export function generateDockerCompose(ctx: InfraContext): string {
  const project = ctx.projectName || `${ctx.domain}-platform`;
  
  return `# Docker Compose for ${project}
# Generated by Intelligent Platform Launcher

version: '3.8'

services:
  app:
    build:
      context: .
      dockerfile: Dockerfile
    container_name: ${project}-app
    restart: unless-stopped
    ports:
      - "3000:3000"
    environment:
      - NODE_ENV=production
      - DATABASE_URL=\${DATABASE_URL}
      - REDIS_URL=redis://redis:6379
    depends_on:
      db:
        condition: service_healthy
      redis:
        condition: service_healthy
    networks:
      - app-network
    deploy:
      replicas: ${ctx.appServers}
      resources:
        limits:
          cpus: '1'
          memory: 1G
        reservations:
          cpus: '0.5'
          memory: 512M

  db:
    image: ${ctx.database === 'postgresql' ? 'postgres:16-alpine' : ctx.database === 'mysql' ? 'mysql:8' : ctx.database === 'mongodb' ? 'mongo:7' : 'postgres:16-alpine'}
    container_name: ${project}-db
    restart: unless-stopped
    environment:
${ctx.database === 'postgresql' ? `      - POSTGRES_USER=\${DB_USER:-admin}
      - POSTGRES_PASSWORD=\${DB_PASSWORD}
      - POSTGRES_DB=\${DB_NAME:-${project.replace(/-/g, '_')}}` : 
ctx.database === 'mysql' ? `      - MYSQL_ROOT_PASSWORD=\${DB_PASSWORD}
      - MYSQL_DATABASE=\${DB_NAME:-${project.replace(/-/g, '_')}}
      - MYSQL_USER=\${DB_USER:-admin}
      - MYSQL_PASSWORD=\${DB_PASSWORD}` :
`      - MONGO_INITDB_ROOT_USERNAME=\${DB_USER:-admin}
      - MONGO_INITDB_ROOT_PASSWORD=\${DB_PASSWORD}`}
    volumes:
      - db-data:/var/lib/${ctx.database === 'postgresql' ? 'postgresql/data' : ctx.database === 'mysql' ? 'mysql' : 'mongodb'}
    ports:
      - "${ctx.database === 'postgresql' ? '5432' : ctx.database === 'mysql' ? '3306' : '27017'}:${ctx.database === 'postgresql' ? '5432' : ctx.database === 'mysql' ? '3306' : '27017'}"
    networks:
      - app-network
    healthcheck:
      test: ${ctx.database === 'postgresql' ? '["CMD-SHELL", "pg_isready -U admin"]' : ctx.database === 'mysql' ? '["CMD", "mysqladmin", "ping", "-h", "localhost"]' : '["CMD", "mongosh", "--eval", "db.adminCommand(\\"ping\\")"]'}
      interval: 10s
      timeout: 5s
      retries: 5

  redis:
    image: redis:7-alpine
    container_name: ${project}-redis
    restart: unless-stopped
    command: redis-server --appendonly yes --requirepass \${REDIS_PASSWORD}
    volumes:
      - redis-data:/data
    ports:
      - "6379:6379"
    networks:
      - app-network
    healthcheck:
      test: ["CMD", "redis-cli", "ping"]
      interval: 10s
      timeout: 5s
      retries: 5

  nginx:
    image: nginx:alpine
    container_name: ${project}-nginx
    restart: unless-stopped
    ports:
      - "80:80"
      - "443:443"
    volumes:
      - ./nginx.conf:/etc/nginx/nginx.conf:ro
      - ./ssl:/etc/nginx/ssl:ro
    depends_on:
      - app
    networks:
      - app-network

networks:
  app-network:
    driver: bridge

volumes:
  db-data:
  redis-data:
`;
}

export function generateKubernetes(ctx: InfraContext): string {
  const project = ctx.projectName || `${ctx.domain}-platform`;
  
  return `# Kubernetes Manifests for ${project}
# Generated by Intelligent Platform Launcher
---
apiVersion: v1
kind: Namespace
metadata:
  name: ${project}
  labels:
    app: ${project}
---
apiVersion: v1
kind: ConfigMap
metadata:
  name: ${project}-config
  namespace: ${project}
data:
  NODE_ENV: "production"
  LOG_LEVEL: "info"
---
apiVersion: v1
kind: Secret
metadata:
  name: ${project}-secrets
  namespace: ${project}
type: Opaque
stringData:
  DATABASE_URL: "postgresql://admin:password@${project}-db:5432/${project.replace(/-/g, '_')}"
  REDIS_URL: "redis://:password@${project}-redis:6379"
---
apiVersion: apps/v1
kind: Deployment
metadata:
  name: ${project}-app
  namespace: ${project}
  labels:
    app: ${project}
    component: app
spec:
  replicas: ${ctx.appServers}
  selector:
    matchLabels:
      app: ${project}
      component: app
  template:
    metadata:
      labels:
        app: ${project}
        component: app
    spec:
      containers:
        - name: app
          image: ${project}:latest
          ports:
            - containerPort: 3000
          envFrom:
            - configMapRef:
                name: ${project}-config
            - secretRef:
                name: ${project}-secrets
          resources:
            requests:
              memory: "256Mi"
              cpu: "250m"
            limits:
              memory: "1Gi"
              cpu: "1000m"
          livenessProbe:
            httpGet:
              path: /health
              port: 3000
            initialDelaySeconds: 30
            periodSeconds: 10
          readinessProbe:
            httpGet:
              path: /health
              port: 3000
            initialDelaySeconds: 5
            periodSeconds: 5
---
apiVersion: v1
kind: Service
metadata:
  name: ${project}-app
  namespace: ${project}
spec:
  selector:
    app: ${project}
    component: app
  ports:
    - port: 80
      targetPort: 3000
  type: ClusterIP
---
apiVersion: networking.k8s.io/v1
kind: Ingress
metadata:
  name: ${project}-ingress
  namespace: ${project}
  annotations:
    kubernetes.io/ingress.class: nginx
    cert-manager.io/cluster-issuer: letsencrypt-prod
spec:
  tls:
    - hosts:
        - ${project}.example.com
      secretName: ${project}-tls
  rules:
    - host: ${project}.example.com
      http:
        paths:
          - path: /
            pathType: Prefix
            backend:
              service:
                name: ${project}-app
                port:
                  number: 80
---
apiVersion: autoscaling/v2
kind: HorizontalPodAutoscaler
metadata:
  name: ${project}-hpa
  namespace: ${project}
spec:
  scaleTargetRef:
    apiVersion: apps/v1
    kind: Deployment
    name: ${project}-app
  minReplicas: ${ctx.appServers}
  maxReplicas: ${ctx.appServers * 4}
  metrics:
    - type: Resource
      resource:
        name: cpu
        target:
          type: Utilization
          averageUtilization: 70
    - type: Resource
      resource:
        name: memory
        target:
          type: Utilization
          averageUtilization: 80
`;
}

export function generateHelmChart(ctx: InfraContext): string {
  const project = ctx.projectName || `${ctx.domain}-platform`;
  
  return `# Helm Chart for ${project}
# Generated by Intelligent Platform Launcher

# Chart.yaml
apiVersion: v2
name: ${project}
description: Helm chart for ${project}
type: application
version: 1.0.0
appVersion: "1.0.0"

---
# values.yaml
replicaCount: ${ctx.appServers}

image:
  repository: ${project}
  pullPolicy: IfNotPresent
  tag: "latest"

nameOverride: ""
fullnameOverride: ""

serviceAccount:
  create: true
  annotations: {}
  name: ""

podAnnotations: {}
podSecurityContext:
  fsGroup: 1001

securityContext:
  runAsNonRoot: true
  runAsUser: 1001

service:
  type: ClusterIP
  port: 80

ingress:
  enabled: true
  className: nginx
  annotations:
    cert-manager.io/cluster-issuer: letsencrypt-prod
  hosts:
    - host: ${project}.example.com
      paths:
        - path: /
          pathType: Prefix
  tls:
    - secretName: ${project}-tls
      hosts:
        - ${project}.example.com

resources:
  limits:
    cpu: 1000m
    memory: 1Gi
  requests:
    cpu: 250m
    memory: 256Mi

autoscaling:
  enabled: true
  minReplicas: ${ctx.appServers}
  maxReplicas: ${ctx.appServers * 4}
  targetCPUUtilizationPercentage: 70
  targetMemoryUtilizationPercentage: 80

nodeSelector: {}
tolerations: []
affinity: {}

database:
  enabled: true
  type: ${ctx.database}
  host: ""
  port: ${ctx.database === 'postgresql' ? '5432' : ctx.database === 'mysql' ? '3306' : '27017'}
  name: ${project.replace(/-/g, '_')}

redis:
  enabled: true
  host: ""
  port: 6379

env:
  NODE_ENV: production
  LOG_LEVEL: info

secrets:
  databaseUrl: ""
  redisUrl: ""

---
# templates/deployment.yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: {{ include "${project}.fullname" . }}
  labels:
    {{- include "${project}.labels" . | nindent 4 }}
spec:
  {{- if not .Values.autoscaling.enabled }}
  replicas: {{ .Values.replicaCount }}
  {{- end }}
  selector:
    matchLabels:
      {{- include "${project}.selectorLabels" . | nindent 6 }}
  template:
    metadata:
      {{- with .Values.podAnnotations }}
      annotations:
        {{- toYaml . | nindent 8 }}
      {{- end }}
      labels:
        {{- include "${project}.selectorLabels" . | nindent 8 }}
    spec:
      serviceAccountName: {{ include "${project}.serviceAccountName" . }}
      securityContext:
        {{- toYaml .Values.podSecurityContext | nindent 8 }}
      containers:
        - name: {{ .Chart.Name }}
          securityContext:
            {{- toYaml .Values.securityContext | nindent 12 }}
          image: "{{ .Values.image.repository }}:{{ .Values.image.tag }}"
          imagePullPolicy: {{ .Values.image.pullPolicy }}
          ports:
            - name: http
              containerPort: 3000
              protocol: TCP
          livenessProbe:
            httpGet:
              path: /health
              port: http
            initialDelaySeconds: 30
          readinessProbe:
            httpGet:
              path: /health
              port: http
            initialDelaySeconds: 5
          resources:
            {{- toYaml .Values.resources | nindent 12 }}
`;
}
