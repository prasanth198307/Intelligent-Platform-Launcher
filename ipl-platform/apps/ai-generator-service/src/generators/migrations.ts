export interface MigrationContext {
  domain: string;
  database: string;
  tables: Array<{
    name: string;
    columns: Array<{
      name: string;
      type: string;
      primary?: boolean;
      unique?: boolean;
      foreignKey?: string;
    }>;
  }>;
  projectName?: string;
}

function mapTypeToSQL(type: string, database: string): string {
  const typeMap: Record<string, Record<string, string>> = {
    postgresql: {
      'INTEGER': 'INTEGER',
      'BIGINT': 'BIGINT',
      'SERIAL': 'SERIAL',
      'VARCHAR': 'VARCHAR(255)',
      'TEXT': 'TEXT',
      'BOOLEAN': 'BOOLEAN',
      'TIMESTAMP': 'TIMESTAMP WITH TIME ZONE',
      'DATE': 'DATE',
      'DECIMAL': 'DECIMAL(18, 2)',
      'FLOAT': 'REAL',
      'JSON': 'JSONB',
      'JSONB': 'JSONB',
      'UUID': 'UUID',
    },
    mysql: {
      'INTEGER': 'INT',
      'BIGINT': 'BIGINT',
      'SERIAL': 'INT AUTO_INCREMENT',
      'VARCHAR': 'VARCHAR(255)',
      'TEXT': 'TEXT',
      'BOOLEAN': 'TINYINT(1)',
      'TIMESTAMP': 'DATETIME',
      'DATE': 'DATE',
      'DECIMAL': 'DECIMAL(18, 2)',
      'FLOAT': 'FLOAT',
      'JSON': 'JSON',
      'JSONB': 'JSON',
      'UUID': 'CHAR(36)',
    },
  };
  
  const dbTypes = typeMap[database] || typeMap.postgresql;
  return dbTypes[type.toUpperCase()] || 'VARCHAR(255)';
}

export function generateSQLMigration(ctx: MigrationContext): string {
  const project = ctx.projectName || `${ctx.domain}-platform`;
  const timestamp = new Date().toISOString().replace(/[-:T.]/g, '').slice(0, 14);
  
  let sql = `-- Migration: ${project} Initial Schema
-- Generated by Intelligent Platform Launcher
-- Database: ${ctx.database}
-- Timestamp: ${new Date().toISOString()}

`;

  if (ctx.database === 'postgresql') {
    sql += `-- Enable extensions
CREATE EXTENSION IF NOT EXISTS "uuid-ossp";
CREATE EXTENSION IF NOT EXISTS "pgcrypto";

`;
  }

  for (const table of ctx.tables) {
    sql += `-- Table: ${table.name}
CREATE TABLE IF NOT EXISTS ${table.name} (
`;
    
    const columnDefs: string[] = [];
    const foreignKeys: string[] = [];
    
    for (const col of table.columns) {
      let colDef = `  ${col.name} ${mapTypeToSQL(col.type, ctx.database)}`;
      
      if (col.primary) {
        if (ctx.database === 'postgresql' && col.type.toUpperCase() === 'SERIAL') {
          colDef = `  ${col.name} SERIAL PRIMARY KEY`;
        } else if (ctx.database === 'mysql') {
          colDef += ' PRIMARY KEY';
        } else {
          colDef += ' PRIMARY KEY';
        }
      }
      
      if (col.unique && !col.primary) {
        colDef += ' UNIQUE';
      }
      
      if (col.name === 'created_at') {
        colDef += ' DEFAULT CURRENT_TIMESTAMP';
      }
      
      if (col.name === 'updated_at') {
        colDef += ' DEFAULT CURRENT_TIMESTAMP';
      }
      
      columnDefs.push(colDef);
      
      if (col.foreignKey) {
        const refTable = col.foreignKey.split('.')[0];
        const refCol = col.foreignKey.split('.')[1] || 'id';
        foreignKeys.push(`  FOREIGN KEY (${col.name}) REFERENCES ${refTable}(${refCol}) ON DELETE CASCADE`);
      }
    }
    
    sql += columnDefs.join(',\n');
    
    if (foreignKeys.length > 0) {
      sql += ',\n' + foreignKeys.join(',\n');
    }
    
    sql += `
);

`;

    sql += `-- Indexes for ${table.name}
`;
    
    for (const col of table.columns) {
      if (col.foreignKey) {
        sql += `CREATE INDEX IF NOT EXISTS idx_${table.name}_${col.name} ON ${table.name}(${col.name});
`;
      }
    }
    
    if (table.columns.some(c => c.name === 'created_at')) {
      sql += `CREATE INDEX IF NOT EXISTS idx_${table.name}_created_at ON ${table.name}(created_at);
`;
    }
    
    sql += '\n';
  }

  if (ctx.database === 'postgresql') {
    sql += `-- Trigger function for updated_at
CREATE OR REPLACE FUNCTION update_updated_at_column()
RETURNS TRIGGER AS $$
BEGIN
  NEW.updated_at = CURRENT_TIMESTAMP;
  RETURN NEW;
END;
$$ language 'plpgsql';

`;
    
    for (const table of ctx.tables) {
      if (table.columns.some(c => c.name === 'updated_at')) {
        sql += `CREATE TRIGGER update_${table.name}_updated_at
  BEFORE UPDATE ON ${table.name}
  FOR EACH ROW
  EXECUTE FUNCTION update_updated_at_column();

`;
      }
    }
  }

  return sql;
}

export function generateDrizzleSchema(ctx: MigrationContext): string {
  let code = `// Drizzle ORM Schema
// Generated by Intelligent Platform Launcher

import { pgTable, serial, varchar, text, integer, bigint, boolean, timestamp, json, decimal, uuid } from 'drizzle-orm/pg-core';
import { relations } from 'drizzle-orm';

`;

  for (const table of ctx.tables) {
    const tableName = table.name;
    const schemaName = tableName.replace(/_([a-z])/g, (_, l) => l.toUpperCase());
    
    code += `export const ${schemaName} = pgTable('${tableName}', {
`;
    
    for (const col of table.columns) {
      const colName = col.name.replace(/_([a-z])/g, (_, l) => l.toUpperCase());
      let colDef = '';
      
      switch (col.type.toUpperCase()) {
        case 'SERIAL':
          colDef = `serial('${col.name}')`;
          break;
        case 'INTEGER':
          colDef = `integer('${col.name}')`;
          break;
        case 'BIGINT':
          colDef = `bigint('${col.name}', { mode: 'number' })`;
          break;
        case 'VARCHAR':
          colDef = `varchar('${col.name}', { length: 255 })`;
          break;
        case 'TEXT':
          colDef = `text('${col.name}')`;
          break;
        case 'BOOLEAN':
          colDef = `boolean('${col.name}')`;
          break;
        case 'TIMESTAMP':
          colDef = `timestamp('${col.name}', { withTimezone: true })`;
          break;
        case 'JSON':
        case 'JSONB':
          colDef = `json('${col.name}')`;
          break;
        case 'DECIMAL':
          colDef = `decimal('${col.name}', { precision: 18, scale: 2 })`;
          break;
        case 'UUID':
          colDef = `uuid('${col.name}')`;
          break;
        default:
          colDef = `varchar('${col.name}', { length: 255 })`;
      }
      
      if (col.primary) {
        colDef += '.primaryKey()';
      }
      if (col.unique && !col.primary) {
        colDef += '.unique()';
      }
      if (col.name === 'created_at') {
        colDef += '.defaultNow()';
      }
      if (col.name === 'updated_at') {
        colDef += '.defaultNow()';
      }
      
      code += `  ${colName}: ${colDef},
`;
    }
    
    code += `});

`;
  }

  code += `// Relations
`;
  
  for (const table of ctx.tables) {
    const schemaName = table.name.replace(/_([a-z])/g, (_, l) => l.toUpperCase());
    const fkColumns = table.columns.filter(c => c.foreignKey);
    
    if (fkColumns.length > 0) {
      code += `export const ${schemaName}Relations = relations(${schemaName}, ({ one }) => ({
`;
      for (const fk of fkColumns) {
        const refTable = fk.foreignKey!.split('.')[0];
        const refSchema = refTable.replace(/_([a-z])/g, (_, l) => l.toUpperCase());
        const relationName = refTable.replace(/_/g, '');
        const colName = fk.name.replace(/_([a-z])/g, (_, l) => l.toUpperCase());
        
        code += `  ${relationName}: one(${refSchema}, {
    fields: [${schemaName}.${colName}],
    references: [${refSchema}.id],
  }),
`;
      }
      code += `}));

`;
    }
  }

  return code;
}
