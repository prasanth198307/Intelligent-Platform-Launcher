export interface CICDContext {
  domain: string;
  projectName?: string;
  language?: string;
  registry?: string;
  cloudProvider?: string;
}

export function generateGitHubActions(ctx: CICDContext): string {
  const project = ctx.projectName || `${ctx.domain}-platform`;
  
  return `# GitHub Actions CI/CD Pipeline
# Generated by Intelligent Platform Launcher

name: CI/CD Pipeline

on:
  push:
    branches: [main, develop]
  pull_request:
    branches: [main]

env:
  NODE_VERSION: '20'
  REGISTRY: ghcr.io
  IMAGE_NAME: \${{ github.repository }}

jobs:
  lint:
    name: Lint & Type Check
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      
      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: \${{ env.NODE_VERSION }}
          cache: 'npm'
      
      - name: Install dependencies
        run: npm ci
      
      - name: Run ESLint
        run: npm run lint
      
      - name: Run Type Check
        run: npm run typecheck

  test:
    name: Unit & Integration Tests
    runs-on: ubuntu-latest
    needs: lint
    
    services:
      postgres:
        image: postgres:16
        env:
          POSTGRES_USER: test
          POSTGRES_PASSWORD: test
          POSTGRES_DB: test_db
        ports:
          - 5432:5432
        options: >-
          --health-cmd pg_isready
          --health-interval 10s
          --health-timeout 5s
          --health-retries 5
      
      redis:
        image: redis:7
        ports:
          - 6379:6379
        options: >-
          --health-cmd "redis-cli ping"
          --health-interval 10s
          --health-timeout 5s
          --health-retries 5

    steps:
      - uses: actions/checkout@v4
      
      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: \${{ env.NODE_VERSION }}
          cache: 'npm'
      
      - name: Install dependencies
        run: npm ci
      
      - name: Run unit tests
        run: npm run test:unit
        env:
          DATABASE_URL: postgresql://test:test@localhost:5432/test_db
          REDIS_URL: redis://localhost:6379
      
      - name: Run integration tests
        run: npm run test:integration
        env:
          DATABASE_URL: postgresql://test:test@localhost:5432/test_db
          REDIS_URL: redis://localhost:6379
      
      - name: Upload coverage
        uses: codecov/codecov-action@v4
        with:
          token: \${{ secrets.CODECOV_TOKEN }}
          files: ./coverage/lcov.info
          fail_ci_if_error: false

  security:
    name: Security Scan
    runs-on: ubuntu-latest
    needs: lint
    steps:
      - uses: actions/checkout@v4
      
      - name: Run Snyk security scan
        uses: snyk/actions/node@master
        continue-on-error: true
        env:
          SNYK_TOKEN: \${{ secrets.SNYK_TOKEN }}
      
      - name: Run npm audit
        run: npm audit --audit-level=high

  build:
    name: Build & Push Image
    runs-on: ubuntu-latest
    needs: [test, security]
    if: github.event_name == 'push' && github.ref == 'refs/heads/main'
    
    permissions:
      contents: read
      packages: write
    
    outputs:
      image-tag: \${{ steps.meta.outputs.tags }}
    
    steps:
      - uses: actions/checkout@v4
      
      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3
      
      - name: Log in to Container Registry
        uses: docker/login-action@v3
        with:
          registry: \${{ env.REGISTRY }}
          username: \${{ github.actor }}
          password: \${{ secrets.GITHUB_TOKEN }}
      
      - name: Extract metadata
        id: meta
        uses: docker/metadata-action@v5
        with:
          images: \${{ env.REGISTRY }}/\${{ env.IMAGE_NAME }}
          tags: |
            type=sha,prefix=
            type=ref,event=branch
            type=semver,pattern={{version}}
      
      - name: Build and push
        uses: docker/build-push-action@v5
        with:
          context: .
          push: true
          tags: \${{ steps.meta.outputs.tags }}
          labels: \${{ steps.meta.outputs.labels }}
          cache-from: type=gha
          cache-to: type=gha,mode=max

  deploy-staging:
    name: Deploy to Staging
    runs-on: ubuntu-latest
    needs: build
    if: github.ref == 'refs/heads/main'
    environment: staging
    
    steps:
      - uses: actions/checkout@v4
      
      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: \${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: \${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: us-east-1
      
      - name: Deploy to ECS
        run: |
          aws ecs update-service \\
            --cluster ${project}-staging \\
            --service ${project}-app \\
            --force-new-deployment

  deploy-production:
    name: Deploy to Production
    runs-on: ubuntu-latest
    needs: deploy-staging
    environment: production
    
    steps:
      - uses: actions/checkout@v4
      
      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: \${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: \${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: us-east-1
      
      - name: Deploy to ECS
        run: |
          aws ecs update-service \\
            --cluster ${project}-production \\
            --service ${project}-app \\
            --force-new-deployment
      
      - name: Notify deployment
        uses: slackapi/slack-github-action@v1
        with:
          payload: |
            {
              "text": "Production deployment complete for ${project}",
              "blocks": [
                {
                  "type": "section",
                  "text": {
                    "type": "mrkdwn",
                    "text": ":rocket: *${project}* deployed to production"
                  }
                }
              ]
            }
        env:
          SLACK_WEBHOOK_URL: \${{ secrets.SLACK_WEBHOOK }}
`;
}

export function generateGitLabCI(ctx: CICDContext): string {
  const project = ctx.projectName || `${ctx.domain}-platform`;
  
  return `# GitLab CI/CD Pipeline
# Generated by Intelligent Platform Launcher

stages:
  - lint
  - test
  - security
  - build
  - deploy

variables:
  NODE_VERSION: "20"
  DOCKER_TLS_CERTDIR: "/certs"
  IMAGE_TAG: \$CI_REGISTRY_IMAGE:\$CI_COMMIT_SHORT_SHA

default:
  image: node:\$NODE_VERSION-alpine
  cache:
    key:
      files:
        - package-lock.json
    paths:
      - node_modules/

.node-setup:
  before_script:
    - npm ci

lint:
  stage: lint
  extends: .node-setup
  script:
    - npm run lint
    - npm run typecheck
  rules:
    - if: \$CI_PIPELINE_SOURCE == "merge_request_event"
    - if: \$CI_COMMIT_BRANCH == "main"
    - if: \$CI_COMMIT_BRANCH == "develop"

unit-tests:
  stage: test
  extends: .node-setup
  services:
    - postgres:16
    - redis:7
  variables:
    POSTGRES_DB: test_db
    POSTGRES_USER: test
    POSTGRES_PASSWORD: test
    DATABASE_URL: postgresql://test:test@postgres:5432/test_db
    REDIS_URL: redis://redis:6379
  script:
    - npm run test:unit
    - npm run test:integration
  coverage: '/All files[^|]*\\|[^|]*\\s+([\\d.]+)/'
  artifacts:
    reports:
      coverage_report:
        coverage_format: cobertura
        path: coverage/cobertura-coverage.xml
      junit: junit.xml

security-scan:
  stage: security
  extends: .node-setup
  script:
    - npm audit --audit-level=high
  allow_failure: true

dependency-scan:
  stage: security
  image: registry.gitlab.com/gitlab-org/security-products/analyzers/gemnasium
  script:
    - /analyzer run
  artifacts:
    reports:
      dependency_scanning: gl-dependency-scanning-report.json

container-scan:
  stage: security
  image: registry.gitlab.com/gitlab-org/security-products/analyzers/container-scanning
  variables:
    CS_IMAGE: \$IMAGE_TAG
  script:
    - /analyzer run
  artifacts:
    reports:
      container_scanning: gl-container-scanning-report.json
  needs:
    - build

build:
  stage: build
  image: docker:24
  services:
    - docker:24-dind
  before_script:
    - docker login -u \$CI_REGISTRY_USER -p \$CI_REGISTRY_PASSWORD \$CI_REGISTRY
  script:
    - docker build -t \$IMAGE_TAG .
    - docker push \$IMAGE_TAG
    - docker tag \$IMAGE_TAG \$CI_REGISTRY_IMAGE:latest
    - docker push \$CI_REGISTRY_IMAGE:latest
  rules:
    - if: \$CI_COMMIT_BRANCH == "main"

deploy-staging:
  stage: deploy
  image: 
    name: bitnami/kubectl:latest
    entrypoint: [""]
  environment:
    name: staging
    url: https://staging.${project}.example.com
  script:
    - kubectl config set-cluster staging --server=\$KUBE_SERVER --certificate-authority=\$KUBE_CA
    - kubectl config set-credentials gitlab --token=\$KUBE_TOKEN
    - kubectl config set-context staging --cluster=staging --user=gitlab
    - kubectl config use-context staging
    - kubectl set image deployment/${project}-app app=\$IMAGE_TAG -n staging
    - kubectl rollout status deployment/${project}-app -n staging
  rules:
    - if: \$CI_COMMIT_BRANCH == "main"
  needs:
    - build
    - unit-tests
    - security-scan

deploy-production:
  stage: deploy
  image: 
    name: bitnami/kubectl:latest
    entrypoint: [""]
  environment:
    name: production
    url: https://${project}.example.com
  script:
    - kubectl config set-cluster production --server=\$KUBE_SERVER_PROD --certificate-authority=\$KUBE_CA_PROD
    - kubectl config set-credentials gitlab --token=\$KUBE_TOKEN_PROD
    - kubectl config set-context production --cluster=production --user=gitlab
    - kubectl config use-context production
    - kubectl set image deployment/${project}-app app=\$IMAGE_TAG -n production
    - kubectl rollout status deployment/${project}-app -n production
  rules:
    - if: \$CI_COMMIT_BRANCH == "main"
      when: manual
  needs:
    - deploy-staging
`;
}

export function generateJenkinsPipeline(ctx: CICDContext): string {
  const project = ctx.projectName || `${ctx.domain}-platform`;
  
  return `// Jenkins Pipeline for ${project}
// Generated by Intelligent Platform Launcher

pipeline {
    agent any
    
    environment {
        NODE_VERSION = '20'
        DOCKER_REGISTRY = 'your-registry.example.com'
        IMAGE_NAME = '${project}'
        SLACK_CHANNEL = '#deployments'
    }
    
    options {
        buildDiscarder(logRotator(numToKeepStr: '10'))
        timeout(time: 1, unit: 'HOURS')
        disableConcurrentBuilds()
    }
    
    stages {
        stage('Checkout') {
            steps {
                checkout scm
            }
        }
        
        stage('Setup') {
            steps {
                nodejs(nodeJSInstallationName: 'Node 20') {
                    sh 'npm ci'
                }
            }
        }
        
        stage('Lint & Type Check') {
            steps {
                nodejs(nodeJSInstallationName: 'Node 20') {
                    sh 'npm run lint'
                    sh 'npm run typecheck'
                }
            }
        }
        
        stage('Unit Tests') {
            steps {
                nodejs(nodeJSInstallationName: 'Node 20') {
                    sh 'npm run test:unit'
                }
            }
            post {
                always {
                    junit 'junit.xml'
                    publishCoverage adapters: [coberturaAdapter('coverage/cobertura-coverage.xml')]
                }
            }
        }
        
        stage('Integration Tests') {
            steps {
                script {
                    docker.image('postgres:16').withRun('-e POSTGRES_PASSWORD=test') { postgres ->
                        docker.image('redis:7').withRun { redis ->
                            nodejs(nodeJSInstallationName: 'Node 20') {
                                sh """
                                    export DATABASE_URL="postgresql://postgres:test@\${postgres.id}:5432/postgres"
                                    export REDIS_URL="redis://\${redis.id}:6379"
                                    npm run test:integration
                                """
                            }
                        }
                    }
                }
            }
        }
        
        stage('Security Scan') {
            parallel {
                stage('NPM Audit') {
                    steps {
                        sh 'npm audit --audit-level=high || true'
                    }
                }
                stage('OWASP Dependency Check') {
                    steps {
                        dependencyCheck additionalArguments: '--scan ./', odcInstallation: 'OWASP-DC'
                        dependencyCheckPublisher pattern: 'dependency-check-report.xml'
                    }
                }
            }
        }
        
        stage('Build Docker Image') {
            when {
                branch 'main'
            }
            steps {
                script {
                    def image = docker.build("\${DOCKER_REGISTRY}/\${IMAGE_NAME}:\${env.BUILD_NUMBER}")
                    docker.withRegistry("https://\${DOCKER_REGISTRY}", 'docker-registry-credentials') {
                        image.push()
                        image.push('latest')
                    }
                }
            }
        }
        
        stage('Deploy to Staging') {
            when {
                branch 'main'
            }
            steps {
                script {
                    withKubeConfig([credentialsId: 'kubeconfig-staging']) {
                        sh """
                            kubectl set image deployment/${project}-app app=\${DOCKER_REGISTRY}/\${IMAGE_NAME}:\${env.BUILD_NUMBER} -n staging
                            kubectl rollout status deployment/${project}-app -n staging --timeout=5m
                        """
                    }
                }
            }
        }
        
        stage('Deploy to Production') {
            when {
                branch 'main'
            }
            input {
                message "Deploy to production?"
                ok "Deploy"
            }
            steps {
                script {
                    withKubeConfig([credentialsId: 'kubeconfig-production']) {
                        sh """
                            kubectl set image deployment/${project}-app app=\${DOCKER_REGISTRY}/\${IMAGE_NAME}:\${env.BUILD_NUMBER} -n production
                            kubectl rollout status deployment/${project}-app -n production --timeout=5m
                        """
                    }
                }
            }
        }
    }
    
    post {
        success {
            slackSend(channel: env.SLACK_CHANNEL, color: 'good', message: "Build #\${env.BUILD_NUMBER} succeeded for ${project}")
        }
        failure {
            slackSend(channel: env.SLACK_CHANNEL, color: 'danger', message: "Build #\${env.BUILD_NUMBER} failed for ${project}")
        }
        always {
            cleanWs()
        }
    }
}
`;
}
