export interface AuthContext {
  domain: string;
  projectName?: string;
  providers?: string[];
  mfa?: boolean;
}

export function generateJWTAuth(ctx: AuthContext): string {
  const project = ctx.projectName || `${ctx.domain}-platform`;
  
  return `// JWT Authentication Implementation
// Generated by Intelligent Platform Launcher

import jwt from 'jsonwebtoken';
import bcrypt from 'bcryptjs';
import { Request, Response, NextFunction } from 'express';

// Types
interface TokenPayload {
  userId: string;
  email: string;
  role: string;
  iat?: number;
  exp?: number;
}

interface User {
  id: string;
  email: string;
  passwordHash: string;
  role: string;
  mfaEnabled: boolean;
  mfaSecret?: string;
}

// Configuration
const JWT_SECRET = process.env.JWT_SECRET || 'your-secret-key-change-in-production';
const JWT_EXPIRES_IN = process.env.JWT_EXPIRES_IN || '24h';
const JWT_REFRESH_EXPIRES_IN = process.env.JWT_REFRESH_EXPIRES_IN || '7d';
const BCRYPT_ROUNDS = 12;

// Token Generation
export function generateAccessToken(user: User): string {
  const payload: TokenPayload = {
    userId: user.id,
    email: user.email,
    role: user.role,
  };
  
  return jwt.sign(payload, JWT_SECRET, { expiresIn: JWT_EXPIRES_IN });
}

export function generateRefreshToken(user: User): string {
  const payload = { userId: user.id, type: 'refresh' };
  return jwt.sign(payload, JWT_SECRET, { expiresIn: JWT_REFRESH_EXPIRES_IN });
}

export function verifyToken(token: string): TokenPayload {
  return jwt.verify(token, JWT_SECRET) as TokenPayload;
}

// Password Hashing
export async function hashPassword(password: string): Promise<string> {
  return bcrypt.hash(password, BCRYPT_ROUNDS);
}

export async function verifyPassword(password: string, hash: string): Promise<boolean> {
  return bcrypt.compare(password, hash);
}

// Express Middleware
export function authMiddleware(req: Request, res: Response, next: NextFunction) {
  try {
    const authHeader = req.headers.authorization;
    
    if (!authHeader || !authHeader.startsWith('Bearer ')) {
      return res.status(401).json({ error: 'No token provided' });
    }
    
    const token = authHeader.substring(7);
    const payload = verifyToken(token);
    
    (req as any).user = payload;
    next();
  } catch (error: any) {
    if (error.name === 'TokenExpiredError') {
      return res.status(401).json({ error: 'Token expired' });
    }
    return res.status(401).json({ error: 'Invalid token' });
  }
}

export function requireRole(...roles: string[]) {
  return (req: Request, res: Response, next: NextFunction) => {
    const user = (req as any).user;
    
    if (!user) {
      return res.status(401).json({ error: 'Authentication required' });
    }
    
    if (!roles.includes(user.role)) {
      return res.status(403).json({ error: 'Insufficient permissions' });
    }
    
    next();
  };
}

// Auth Routes
import { Router } from 'express';
import { db } from './db'; // Your database module

const authRouter = Router();

// Register
authRouter.post('/register', async (req, res) => {
  try {
    const { email, password, name } = req.body;
    
    // Validate input
    if (!email || !password) {
      return res.status(400).json({ error: 'Email and password required' });
    }
    
    // Check if user exists
    const existing = await db.users.findByEmail(email);
    if (existing) {
      return res.status(409).json({ error: 'Email already registered' });
    }
    
    // Hash password and create user
    const passwordHash = await hashPassword(password);
    const user = await db.users.create({
      email,
      passwordHash,
      name,
      role: 'user',
    });
    
    // Generate tokens
    const accessToken = generateAccessToken(user);
    const refreshToken = generateRefreshToken(user);
    
    // Store refresh token (in DB or Redis)
    await db.refreshTokens.create({
      userId: user.id,
      token: refreshToken,
      expiresAt: new Date(Date.now() + 7 * 24 * 60 * 60 * 1000),
    });
    
    res.status(201).json({
      user: { id: user.id, email: user.email, name: user.name },
      accessToken,
      refreshToken,
    });
  } catch (error) {
    console.error('Registration error:', error);
    res.status(500).json({ error: 'Registration failed' });
  }
});

// Login
authRouter.post('/login', async (req, res) => {
  try {
    const { email, password } = req.body;
    
    // Find user
    const user = await db.users.findByEmail(email);
    if (!user) {
      return res.status(401).json({ error: 'Invalid credentials' });
    }
    
    // Verify password
    const valid = await verifyPassword(password, user.passwordHash);
    if (!valid) {
      return res.status(401).json({ error: 'Invalid credentials' });
    }
    
    // Check MFA
    if (user.mfaEnabled) {
      return res.json({ requiresMfa: true, mfaToken: generateMfaToken(user) });
    }
    
    // Generate tokens
    const accessToken = generateAccessToken(user);
    const refreshToken = generateRefreshToken(user);
    
    await db.refreshTokens.create({
      userId: user.id,
      token: refreshToken,
      expiresAt: new Date(Date.now() + 7 * 24 * 60 * 60 * 1000),
    });
    
    res.json({
      user: { id: user.id, email: user.email, role: user.role },
      accessToken,
      refreshToken,
    });
  } catch (error) {
    console.error('Login error:', error);
    res.status(500).json({ error: 'Login failed' });
  }
});

// Refresh Token
authRouter.post('/refresh', async (req, res) => {
  try {
    const { refreshToken } = req.body;
    
    if (!refreshToken) {
      return res.status(400).json({ error: 'Refresh token required' });
    }
    
    // Verify refresh token
    const payload = jwt.verify(refreshToken, JWT_SECRET) as any;
    
    if (payload.type !== 'refresh') {
      return res.status(401).json({ error: 'Invalid refresh token' });
    }
    
    // Check if token exists in DB
    const storedToken = await db.refreshTokens.findByToken(refreshToken);
    if (!storedToken) {
      return res.status(401).json({ error: 'Refresh token revoked' });
    }
    
    // Get user
    const user = await db.users.findById(payload.userId);
    if (!user) {
      return res.status(401).json({ error: 'User not found' });
    }
    
    // Generate new tokens
    const newAccessToken = generateAccessToken(user);
    const newRefreshToken = generateRefreshToken(user);
    
    // Rotate refresh token
    await db.refreshTokens.delete(storedToken.id);
    await db.refreshTokens.create({
      userId: user.id,
      token: newRefreshToken,
      expiresAt: new Date(Date.now() + 7 * 24 * 60 * 60 * 1000),
    });
    
    res.json({
      accessToken: newAccessToken,
      refreshToken: newRefreshToken,
    });
  } catch (error: any) {
    if (error.name === 'TokenExpiredError') {
      return res.status(401).json({ error: 'Refresh token expired' });
    }
    res.status(401).json({ error: 'Invalid refresh token' });
  }
});

// Logout
authRouter.post('/logout', authMiddleware, async (req, res) => {
  try {
    const { refreshToken } = req.body;
    const userId = (req as any).user.userId;
    
    if (refreshToken) {
      await db.refreshTokens.deleteByToken(refreshToken);
    } else {
      await db.refreshTokens.deleteAllByUser(userId);
    }
    
    res.json({ message: 'Logged out successfully' });
  } catch (error) {
    res.status(500).json({ error: 'Logout failed' });
  }
});

// Get current user
authRouter.get('/me', authMiddleware, async (req, res) => {
  try {
    const userId = (req as any).user.userId;
    const user = await db.users.findById(userId);
    
    if (!user) {
      return res.status(404).json({ error: 'User not found' });
    }
    
    res.json({
      id: user.id,
      email: user.email,
      name: user.name,
      role: user.role,
      mfaEnabled: user.mfaEnabled,
    });
  } catch (error) {
    res.status(500).json({ error: 'Failed to get user' });
  }
});

function generateMfaToken(user: User): string {
  return jwt.sign({ userId: user.id, type: 'mfa' }, JWT_SECRET, { expiresIn: '5m' });
}

export { authRouter };
`;
}

export function generateOAuth(ctx: AuthContext): string {
  const providers = ctx.providers || ['google', 'github'];
  
  return `// OAuth Authentication Implementation
// Generated by Intelligent Platform Launcher

import passport from 'passport';
import { Strategy as GoogleStrategy } from 'passport-google-oauth20';
import { Strategy as GitHubStrategy } from 'passport-github2';
import { Router } from 'express';

// Configuration from environment
const GOOGLE_CLIENT_ID = process.env.GOOGLE_CLIENT_ID!;
const GOOGLE_CLIENT_SECRET = process.env.GOOGLE_CLIENT_SECRET!;
const GITHUB_CLIENT_ID = process.env.GITHUB_CLIENT_ID!;
const GITHUB_CLIENT_SECRET = process.env.GITHUB_CLIENT_SECRET!;
const CALLBACK_URL = process.env.OAUTH_CALLBACK_URL || 'http://localhost:3000';

${providers.includes('google') ? `
// Google OAuth Strategy
passport.use(new GoogleStrategy({
  clientID: GOOGLE_CLIENT_ID,
  clientSecret: GOOGLE_CLIENT_SECRET,
  callbackURL: \`\${CALLBACK_URL}/auth/google/callback\`,
  scope: ['profile', 'email'],
}, async (accessToken, refreshToken, profile, done) => {
  try {
    // Find or create user
    let user = await db.users.findByOAuthId('google', profile.id);
    
    if (!user) {
      user = await db.users.create({
        email: profile.emails?.[0]?.value,
        name: profile.displayName,
        oauthProvider: 'google',
        oauthId: profile.id,
        avatar: profile.photos?.[0]?.value,
        role: 'user',
      });
    }
    
    return done(null, user);
  } catch (error) {
    return done(error as Error);
  }
}));
` : ''}

${providers.includes('github') ? `
// GitHub OAuth Strategy
passport.use(new GitHubStrategy({
  clientID: GITHUB_CLIENT_ID,
  clientSecret: GITHUB_CLIENT_SECRET,
  callbackURL: \`\${CALLBACK_URL}/auth/github/callback\`,
  scope: ['user:email'],
}, async (accessToken: string, refreshToken: string, profile: any, done: any) => {
  try {
    let user = await db.users.findByOAuthId('github', profile.id);
    
    if (!user) {
      const email = profile.emails?.[0]?.value || \`\${profile.username}@github.local\`;
      
      user = await db.users.create({
        email,
        name: profile.displayName || profile.username,
        oauthProvider: 'github',
        oauthId: profile.id,
        avatar: profile.photos?.[0]?.value,
        role: 'user',
      });
    }
    
    return done(null, user);
  } catch (error) {
    return done(error);
  }
}));
` : ''}

// Serialize user for session
passport.serializeUser((user: any, done) => {
  done(null, user.id);
});

passport.deserializeUser(async (id: string, done) => {
  try {
    const user = await db.users.findById(id);
    done(null, user);
  } catch (error) {
    done(error);
  }
});

// OAuth Routes
const oauthRouter = Router();

${providers.includes('google') ? `
// Google OAuth
oauthRouter.get('/google', passport.authenticate('google', {
  scope: ['profile', 'email'],
}));

oauthRouter.get('/google/callback',
  passport.authenticate('google', { failureRedirect: '/login?error=oauth_failed' }),
  (req, res) => {
    // Generate JWT tokens after successful OAuth
    const user = req.user as any;
    const accessToken = generateAccessToken(user);
    const refreshToken = generateRefreshToken(user);
    
    // Redirect with tokens (or set cookies)
    res.redirect(\`/auth/success?token=\${accessToken}\`);
  }
);
` : ''}

${providers.includes('github') ? `
// GitHub OAuth
oauthRouter.get('/github', passport.authenticate('github', {
  scope: ['user:email'],
}));

oauthRouter.get('/github/callback',
  passport.authenticate('github', { failureRedirect: '/login?error=oauth_failed' }),
  (req, res) => {
    const user = req.user as any;
    const accessToken = generateAccessToken(user);
    const refreshToken = generateRefreshToken(user);
    
    res.redirect(\`/auth/success?token=\${accessToken}\`);
  }
);
` : ''}

// Middleware to initialize passport
export function initializeOAuth(app: any) {
  app.use(passport.initialize());
  app.use(passport.session());
  app.use('/auth', oauthRouter);
}

export { oauthRouter };

// Import from jwt-auth module
import { generateAccessToken, generateRefreshToken } from './jwt-auth';
import { db } from './db';
`;
}
